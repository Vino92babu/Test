# Class 

# Classrm--> Teacher -->class
# Class leader --> object.

# class   Test:
#     def myfun(self):
#         print("Hi how are you")
# abc=Test()
# abc.myfun()

# class rrr:
#     A =10
#     def myfun(self):
#         print("Hi how are you")
# u = rrr()
# print(u.A)

# self

# class demo:
#     def myfun1(self,name,age):
#         self.name=name
#         self.age=age
#     def myfun2(self):
#         print("Name:",self.name)
#         print("Age:",self.age)
# obj = demo()
# obj.myfun1("vino",30)
# obj.myfun2()

# Encapsulation--> Hiding data and restricting direct access.
# Abstraction--> Hiding Implementation details and showing only data to user.
# Inheritance --> 

# class Animal:
#     def tt(self):
#         print("Animal makes sound")

# class Dog(Animal):
#     def sound(self):
#         print("Dog barks")


# class cat(Animal):
#     def sound(self):
#         print("cat")

# # Creating object
# animal=Animal()
# dog=Dog()
# Cat=cat()
# # animal.sound()
# dog.sound()
# dog.tt()
# Cat.

# Polymorphism--> using a single interface to represent different types

# class Home:
#     def Vinoth(self):
#         print("is a Child")
# class School:
#     def Vinoth(self):
#         print("student")
# class Collge:
#     def Vinoth(self):
#         print("c_Student")
# for obj in [Home(),School(),Collge()]:
#     obj.Vinoth()
